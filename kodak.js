'use strict';

const EventEmitter = require('events');
const async = require("async");
const TCPBase = require('tcp-base');
const dgram = require("dgram");
const func = require('./func.js');
const resp = require('./resp.js');

class KodakBase extends TCPBase {

	constructor(options) {
		super(options);

		this.SentEvent = new EventEmitter();

		this.on('request', (entity) => {
			const packet = resp(entity.header, entity.data);

			if (!packet) {return;}

			print_hex(packet, 'auto echo response:');

			let id = this.getId(packet);

			this.send({
				id: id,
				data: packet,
				timeout: 5000,
				oneway: true,
			}, ()=>{
				let event_name = 'sent_'+id.toString(16);
				console.log('emit name: ' + event_name);
				this.SentEvent.emit(event_name);
			});
		});
	}

	gen_ED03_174_packet() {
		let packet = new Buffer([ 
			0x2d, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
			0xed, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 
			0x0a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
		]);
		return {id: this.getId(packet), data: packet, timeout: 5000, oneway: false};
	}		

	gen_ED03_146_packet(param1) {
		let packet = new Buffer([ 
			0x2d, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
			0xed, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 
			0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x06, 0x00, 0x00, 0x00,
			0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
		]);
		packet.writeInt32LE(param1, 0x58);
		return {id: this.getId(packet), data: packet, timeout: 5000, oneway: false};
	}

	gen_ED03_190_packet() {
		let packet = new Buffer([ 
			0x2d, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
			0xed, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 
			0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
		]);
		return {id: this.getId(packet), data: packet, timeout: 5000, oneway: false};
	}

	gen_E903_190_packet(param1, param2) {
		let packet = new Buffer([ 
			0x2d, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
			0xe9, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
			0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
		]);

		packet.writeInt32LE(param1, 0x58);
		packet.writeInt32LE(param2, 0x84);
		return {id: this.getId(packet), data: packet, timeout: 5000, oneway: false};
	}

	gen_EF03_150_packet() {
		let packet = new Buffer([ 
			0x2d, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
			0xef, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
		]);
		return {id: this.getId(packet), data: packet, timeout: 5000, oneway: false};
	}


	getId(header) {
		return header.readInt32LE(0x8);
	}

	get_cmd_name(packet) {

	}

	getBodyLength(header) {
		const block_header_size = 0x10;
		const tail_size = 0x14;
		const contents_size = header.readInt32LE(0x04);
		let block_mode = header.readInt32LE(0x1c);

		between(contents_size,0,Number.MAX_VALUE) || console.log('read buffer error');
		between(block_mode,0,Number.MAX_VALUE) || console.log('read buffer error');


		let body_size = 0;
		switch(block_mode) {
		    case 0:
			body_size = tail_size + contents_size; 
			break;
		    case 1:
			body_size = tail_size + block_header_size * 2;
			break;
		    case 2:
			body_size = tail_size + block_header_size * 3 + contents_size;
			break;
		    default:
			console.log('new block mode');
		}

		print_json({
			header_size: hexval(this.options.headerLength),
			tail_size: hexval(tail_size),
			contents_size: hexval(contents_size),
			block_mode: hexval(block_mode),
			block_header_size: hexval(block_header_size),
			body_size: hexval(body_size)
		}, 'getBodyLength:');

		return  body_size;
	}

	decode(body, header) {
		//print_hex(header, 'decode packet:');
		return {
			id: this.getId(header),
			data: body,
			header: header,
		};
	}
}

class Kodak extends KodakBase{
	prepare_camera(done) {
		let kodak = this;

		async.waterfall([function(callback) {
			let packet = kodak.gen_E903_190_packet(0x00000002, 0x00000001);
			print_hex(packet.data, 'send first packet:');
			kodak.send(packet, (err, res) => {
				print_hex(res, 'recv response1:');
				//kodak.SentEvent.once('sent_bba', ()=>{
					callback(err, res);
				//});
			});
		},

		function(res, callback) {
			let packet = kodak.gen_E903_190_packet(0x00002400, 0x00000003);
			print_hex(packet.data, 'open camera website:');
			kodak.send(packet, (err, res) => {
				print_hex(res, 'recv response web:');
				//kodak.SentEvent.once('sent_bba', ()=>{
					callback(err, res);
				//});
			});
		},

		function(res, callback) {
			let packet = kodak.gen_E903_190_packet(0x00000008, 0x00000003);
			print_hex(packet.data, 'set capture picture:');
			kodak.send(packet, (err, res) => {
				print_hex(res, 'recv response2:');
				callback(err, res);
			});
		},
/*
		function(res, callback) {
			let packet = kodak.gen_ED03_146_packet(0x00000006);
			print_hex(packet.data, 'send capture picture mode:');
			kodak.send(packet, (err, res) => {
				print_hex(res, 'recv response3:');
				callback(err, res);
			});
		},

		function(res, callback) {
			let packet = kodak.gen_ED03_174_packet();
			print_hex(packet.data, 'send capture picture size:');
			kodak.send(packet, (err, res) => {
				print_hex(res, 'recv response4:');
				callback(err, res);
			});
		},
*/

		],function (err, result) {
			if (err) {
				console.error(err);
			} else {
				done(result);
			}
		});
	}
}

function main(config) {
	print_json(config, 'Configuration from UDP port 5176: ');

	const kodak = new Kodak({
		host: config['camera_address'],
		port: config['command_port'],
		needHeartbeat: false,
		headerLength: 0x34
	});

	kodak.prepare_camera((result)=>{
		let packet = kodak.gen_EF03_150_packet();
		print_hex(packet.data, 'send capture snapshot:');
		kodak.send(packet, (err, res) => {
			print_hex(res, 'recv response5:');
		});
	});

};

get_config((config) => {main(config);});

