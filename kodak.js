'use strict';

const EventEmitter = require('events');
const async = require("async");
const net = require("net");
const path = require('path');
const request = require('request');
const spawn = require('child_process').spawn;
const fs = require('fs');  
const assert = require('assert');
const TCPBase = require('tcp-base');
const func = require('./global.js');
const resp = require('./resp.js');
const parseString = require('xml2js').parseString;


class KodakBase extends TCPBase
{
	constructor(options) {
		assert(options.localAddress, 'options.localAddress is required');

		options.host = options.host || CAM_HOST;
		options.port = options.port || CAM_CMD_PORT;
		options.headerLength = 0x34;
		options.needHeartbeat = false;

		super(options);
		let self = this;

		this.SentEvent = new EventEmitter();

		this.on('request', (entity) => {
			if ((entity.header[0] !== 0x2b) && (entity.header[0] !== 0x2d)) {
				return;
			};

			let id = this.getId(entity.header);

			//auto handle heartbeat
			if (id === 0x07d2) {
				process.nextTick(()=>{self.send(resp(id))});
				return;
			}

			entity.packet = Buffer.concat([entity.header, entity.data]); 

			//auto handle event of service started
			if ([0x0bba,0x0bb9,0x0bbb].indexOf(id) !== -1) {
				process.nextTick(()=>{
					self.send(resp(id),()=>{
						//console.log('seens operation(0x'+hexval(id)+') complete.');
						this.SentEvent.emit(self.getName(id), entity);
					});
				});
				return;
			}

			
			if ([0x07d1].indexOf(id) === -1) {
				print_hex(entity.packet, 'receive unknow message:');
			}

			this.SentEvent.emit(self.getName(id), entity);
		});
	}

	gen_FF03_370_packet() {
		let packet = new Buffer([ 
			0x2d, 0x00, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x00, 
			0xff, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00,
			0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		]);
		return {id: this.getId(packet), data: packet, timeout: 5000, oneway: false};
	}

	gen_EB03_150_packet() {
		let packet = new Buffer([ 
			0x2d, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
			0xeb, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x51, 0x59, 0xd7, 0x1f, 0x00, 0x00, 0x00, 0x00,
			0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		]);
		return {id: this.getId(packet), data: packet, timeout: 5000, oneway: false};
	}

	gen_XX03_118_packet(param1) {
		let packet = new Buffer([ 
			0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0xfc, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		]);
		packet.writeInt32LE(param1, 0x08);
		return {id: this.getId(packet), data: packet, timeout: 5000, oneway: false};
	}

	gen_ED03_174_packet() {
		let packet = new Buffer([ 
			0x2d, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
			0xed, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 
			0x0a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
		]);
		return {id: this.getId(packet), data: packet, timeout: 5000, oneway: false};
	}		

	gen_ED03_146_packet(param1) {
		let packet = new Buffer([ 
			0x2d, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
			0xed, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 
			0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x06, 0x00, 0x00, 0x00,
			0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
		]);
		packet.writeInt32LE(param1, 0x58);
		return {id: this.getId(packet), data: packet, timeout: 5000, oneway: false};
	}

	gen_ED03_190_packet() {
		let packet = new Buffer([ 
			0x2d, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
			0xed, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 
			0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
		]);
		return {id: this.getId(packet), data: packet, timeout: 5000, oneway: false};
	}

	gen_E903_190_packet(param1, param2) {
		let packet = new Buffer([ 
			0x2d, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
			0xe9, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
			0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
		]);

		packet.writeInt32LE(param1, 0x58);
		packet.writeInt32LE(param2, 0x84);
		return {id: this.getId(packet), data: packet, timeout: 5000, oneway: false};
	}

	gen_EF03_150_packet() {
		let packet = new Buffer([ 
			0x2d, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
			0xef, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
		]);
		return {id: this.getId(packet), data: packet, timeout: 5000, oneway: false};
	}

	getId(header) {
		return header.readInt32LE(0x8);
	}

	getName(headerOrId) {
		let id;
		if (typeof headerOrId ===  'number') {
			id = headerOrId;  
		} else {
			id = this.getId(headerOrId);
		}
		return 'packet_'+id.toString(16);
	}

	getBodyLength(header) {
		const id = this.getId(header);
		const block_header_size = 0x10;
		const tail_size = 0x14;
		const contents_size = header.readInt32LE(0x04);
		let block_mode = header.readInt32LE(0x1c);

		between(contents_size,0,Number.MAX_VALUE) || console.log('read buffer error');
		between(block_mode,0,Number.MAX_VALUE) || console.log('read buffer error');


		let body_size = 0;
		switch(block_mode) {
		    case 0x00:
			body_size = tail_size + contents_size; 
			break;
		    case 0x01:
			body_size = tail_size + contents_size; 
			body_size +=  block_header_size + 0x08;
			break;
		    case 0x02:
			body_size = tail_size + contents_size; 
			body_size +=  block_header_size * 3;
			break;
		    case 0x22:
			if (id === 0x03ec) {
				body_size = 1514 + 1130 - 54*2 - 0x34;
			} else {
				print_hex(header, 'new block mode(22):');
			}
			break;
		    case 0x23:
			if (id === 0x0bb9) {
				body_size = 1514 + 1162 - 54*2 - 0x34;
			} else {
				print_hex(header, 'new block mode(23):');
			}
			break;
		    default:
			print_hex(header, 'new block mode: ' + block_mode);
		}

		body_size || print_json({
			header_size: hexval(this.options.headerLength),
			tail_size: hexval(tail_size),
			contents_size: hexval(contents_size),
			block_mode: hexval(block_mode),
			block_header_size: hexval(block_header_size),
			body_size: hexval(body_size)
		}, 'getBodyLength:');

		return  body_size;
	}

	decode(body, header) {
		//print_hex(header, 'decode packet:');
		return {
			id: this.getId(header),
			data: body,
			header: header,
		};
	}
}

class Kodak extends KodakBase{

	service_on_ready(done) {
		done = done || function(){};
		let self = this;

		async.waterfall([function(callback) {
			let packet = self.gen_E903_190_packet(0x0002, 0x0001);
			self.send(packet, (err, res) => {});

			let is_action = false;
			self.SentEvent.once(self.getName(0x7d1), (entity)=>{
				if (is_action) return;
				is_action = true;
				self.send(resp(0x7d1), (err, res)=>{
					process.nextTick(()=>{callback(err, res)});
				});
			});

			setTimeout(()=>{
				if (is_action) return;
				is_action = true;
				process.nextTick(()=>{callback(null, 'done')});
			}, 100);

		},function(res, callback) {
			let packet = self.gen_XX03_118_packet(0x03ea);
			self.send(packet, (err,res)=> {process.nextTick(()=>{callback(err, res)})});

		},function(res, callback) {
			let packet = self.gen_XX03_118_packet(0x03ec);
			self.send(packet, (err,res)=> {process.nextTick(()=>{callback(err, res)})});

		},function(res, callback) {
			let packet = self.gen_XX03_118_packet(0x03fc);
			self.send(packet, (err,res)=> {process.nextTick(()=>{callback(err, res)})});

		},function(res, callback) {
			let packet = self.gen_EB03_150_packet();
			self.send(packet, (err,res)=> {process.nextTick(()=>{callback(err, res)})});

		},function(res, callback) {
			let packet = self.gen_FF03_370_packet();
			self.send(packet, (err,res)=> {process.nextTick(()=>{callback(err, res)})});

		},function(res, callback) {
			let packet = self.gen_XX03_118_packet(0x03ea);
			self.send(packet, (err,res)=> {process.nextTick(()=>{callback(err, res)})});

		}],function (err, result) {
			err && console.error(err);
			done(err, result);
		});
		
		return this;
	}

	http_photos_ready(done) {return this.open_website(done);}
	http_videos_ready(done) {return this.open_website(done, false);}

	open_website(done, is_photo=true) {
		done = done || function(){};
		let cmd_id = is_photo? 0x2400 : 0x4400;
		let packet = this.gen_E903_190_packet(cmd_id, 0x0003);
		this.send(packet, done);
		return this;
	}

	take_snapshot(done, wait) {
		done = done || function(){};
		wait = wait || function(cb){cb()};
		let self = this;

		async.waterfall([function(callback) {
			let packet = self.gen_E903_190_packet(0x0008, 0x0003);
			self.send(packet, (err, res) => {
				setTimeout(()=> {callback(err, res)}, 100);
			});

		}, (res, callback) => {
			let packet = self.gen_ED03_146_packet(0x0006);
			self.send(packet, (err, res) => {callback(err, res)});

		}, (res, callback) => {
			let packet = self.gen_ED03_174_packet();
			self.send(packet, (err, res) => {callback(err, res)});

		}, (res, callback) => {
			wait(()=> {
				let packet = self.gen_EF03_150_packet(); //trigger the action
				self.send(packet, (err, res) => {callback(err, 'done')});
			});

		}, (res, callback) => {
			self.SentEvent.once(self.getName(0x0bbb), (entity)=>{
				process.nextTick(()=>{callback(null, 'done')});
			});

		},],(err, result) => {
			err && console.error(err);
			done(err, result);
		});

		return this;
	}

	set_offline(done) {
		done = done || function(){};
		let packet = this.gen_E903_190_packet(0x0800, 0x0002);
		this.send(packet, done);
		return  this;
	}

}

class KodakWeb  {
	constructor(options) {
		this.options = Object.assign({}, {
			host:  CAM_HOST,
			port: CAM_WEB_PORT,
			timeout: CAM_WEB_TIMEOUT,
		}, options);

		let port_str = (this.options.port == 80)? '' : (':'+this.options.port);
		this.root_path = 'http://'+ this.options.host + port_str;

		assert(this.options.localAddress, 'options.localAddress is required');
	}

	download(url, tofile, done) {
		async.waterfall ([(callback) => {
			done = done || function(){};
			if (!url) {
				callback('The request url is required');
				return;
			}
			if (!tofile) {
				callback('The save dest file is required');
			}

			let req_opts = {
				url: url, 
				localAddress: this.options.localAddress,
			};
			callback(null, req_opts);

		}, (res, callback) => {
			let curl = spawn('curl', ['--interface', iface[res.localAddress], '--output', tofile, res.url])

			curl.stdout.on('data', (data) => { });
			curl.stdout.on('end', (data) => {});

			curl.on('error', (err) => {
				callback('error: ' + err);
			});

			curl.on('exit', (code, signal) => {
				if (code != 0) {
					callback('Failed: ' + code + ' signal: ' + signal);
				} else {
					if (fs.existsSync(tofile)) {
						callback(null, tofile);
					} else {
						callback('Failed: File not exists');
					}
				}
			});

		}], (err, res) => {
			done(err, res);
		});
	}

	get_list(done) {
		var self = this;
		done = done || function(){};

		async.waterfall([(callback)=> {
			let url = self.root_path + '/?custom=1';
			let tofile = __dirname + '/cache/'+self.options.localAddress+'_custom.xml'; 
			fs.unlink(tofile, (err)=>{
				this.download(url, tofile, (err, res) => {
					if (!err) {
						let body = fs.readFileSync(tofile, 'utf-8');
						callback(null, body);
					} else {
						callback('download list error');
					}

				});
			});
			return;

			//fixme
			request({url: self.root_path + '/?custom=1',
				 timeout: self.options.timeout,
				 localAddress: self.options.localAddress,
			}, function (err, response, body) {
				if (!err && response.statusCode == 200) {
					callback(null, body);
				} else {
					callback('request error');
				}
			});

		}, (res, callback) => {
			console.log(res);
			parseString(res, (err, result) => {
				if (err) {
					callback(err);
					return;
				}
				let imgs = new Array();
				for (var i=0; i<result.LIST.FILECOUNT; i++) 
				{
					let file = result.LIST.ALLFile[0].File[i];
					let timecode = parseInt(file.TIMECODE[0]);
					let name = file.NAME[0];
					let index = parseInt(path.basename(name,'.JPG').replace('_',''));

					imgs.push({
						name: name,
						index: index,
						path: self.root_path + file.FPATH,
						timecode: timecode,
					});
				}
				callback(null, imgs.sort((a,b)=>{
					return a.index - b.index;
				}));
			});

		}], (err, result) => {
			result = result || new Array();
			done(err, result);
		});
	}
}	

module.exports = [Kodak, KodakWeb];
